# == 和 === 

等于运算符\==检查其两个操作数是否相等，并返回Boolean结果。与严格相等运算符\===不同，它会尝试强制类型转换并且比较不同类型的操作数。

# ==的基本规则

相等运算符（==和!=）使用抽象相等比较算法比较两个操作数。可以大致概括如下：

- 1.如果两个操作数都是对象，则仅当两个操作数都引用同一个对象时才返回true。
- 2.如果一个操作数是null，另一个操作数是undefined，则返回true。
- 3.如果两个操作数是不同类型的，就会尝试在比较之前将它们转换为相同类型：
    - 3.1 当数字与字符串进行比较时，会尝试将字符串转换为数字值。
    - 3.2 如果操作数之一是Boolean，则将布尔操作数转换为1或0。
        - 3.2.1 如果是 true，则转换为1。
        - 3.2.2 如果是 false，则转换为0。
    - 3.3 如果操作数之一是对象，另一个是数字或字符串，会尝试使用对象的valueOf()和toString()方法将对象转换为原始值。
- 4.如果操作数具有相同的类型，则将它们进行如下比较：
    - 4.1 String：true仅当两个操作数具有相同顺序的相同字符时才返回。
    - 4.2 Number：true仅当两个操作数具有相同的值时才返回。+0并被-0视为相同的值。如果任一操作数为NaN，则返回false。
    - 4.3 Boolean：true仅当操作数为两个true或两个false时才返回true。
  
此运算符与严格等于===运算符之间最显着的区别在于，严格等于运算符不尝试类型转换。相反，严格相等运算符始终将不同类型的操作数视为不同。

#### 说人话就是
1.如果相等操作符两边的操作数，不包含 null 或者 undefined，且两个操作数不全是对象，在执行相等比较之前，会先调用 Number() 将两个操作数强制转为 Number 类型，然后进行比较
```
'55' == 55;       //true
false == 0;       //true
"wise" == 3;      //false （ Number("wise") -> NaN ）
[] == 0;          //true  （ Number([]) -> 0 ）
```

2.[] == [] 和 {} == {}

在 JavaScript 中，Object、Array、Function、RegExp、Date 都是引用类型

声明引用类型的时候，变量名保存在 js 的栈内存里面，而对应的值保存在堆内存里面

而这个变量在栈内存中实际保存的是：这个值在堆内存中的地址，也就是指针

参考之前的第一条“如果两个操作数都是对象，则仅当两个操作数都引用同一个对象时才返回true。” 

于是
```
[] == [];    //false
{} == {};    //false
```

3.[]==false
```
[] == false // true
```
根据第三条3.2的规则 将会转换成 0 == 0 所以是true

4.[] == ![] 和 {} == !{}
ECMAScript 中规定，逻辑非 (!) 的优先级高于相等操作符 ( == )

所以在比较 [] == ![] 的时候，先计算 ![] 得到布尔值 false

实际上比较的是 [] == false 和 {} == false

```
[] == ![];   //true
{} == !{};   //false
```


